<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Particle System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        /* Video feed hidden but active */
        #video-input {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transform: scaleX(-1); /* Mirror view */
            z-index: 10;
        }

        /* Modern UI Panel */
        #ui-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(15, 15, 15, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        button {
            background: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        button:hover { background: #444; }
        button.active { background: #007AFF; }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            background: none;
            cursor: pointer;
        }

        .status {
            font-size: 12px;
            color: #888;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>

<video id="video-input" autoplay></video>

<div id="ui-panel">
    <div class="control-group">
        <label>Template</label>
        <div class="btn-group">
            <button onclick="setTemplate('hearts')" id="btn-hearts">Hearts</button>
            <button onclick="setTemplate('flowers')" id="btn-flowers">Flowers</button>
            <button onclick="setTemplate('fireworks')" id="btn-fireworks" class="active">Fireworks</button>
        </div>
    </div>

    <div class="control-group">
        <label>Particle Color</label>
        <input type="color" id="colorPicker" value="#00ffff" oninput="updateColor(this.value)">
    </div>

    <div class="status" id="hand-status">Waiting for camera...</div>
</div>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    /**
     * INITIALIZATION & SCENE SETUP
     */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 5;

    let particles;
    let particleGeometry;
    let particleMaterial;
    const particleCount = 5000;
    let currentTemplate = 'fireworks';
    let targetScale = 1;
    let targetExpansion = 1;
    let handX = 0, handY = 0;

    /**
     * PARTICLE GENERATORS
     */
    function createParticles() {
        if (particles) {
            scene.remove(particles);
            particleGeometry.dispose();
            particleMaterial.dispose();
        }

        particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            let x, y, z;

            if (currentTemplate === 'hearts') {
                // Parametric Heart Equation
                const t = Math.random() * Math.PI * 2;
                x = 16 * Math.pow(Math.sin(t), 3) / 10;
                y = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 10;
                z = (Math.random() - 0.5) * 0.5;
            } else if (currentTemplate === 'flowers') {
                // Phyllotaxis (Flower) pattern
                const angle = i * 0.1375;
                const r = 0.05 * Math.sqrt(i);
                x = r * Math.cos(angle);
                y = r * Math.sin(angle);
                z = (Math.random() - 0.5) * 0.2;
            } else {
                // Fireworks (Sphere)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 2;
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            }

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // Store base positions in velocity attribute to use for expansion math
            velocities[i * 3] = x;
            velocities[i * 3 + 1] = y;
            velocities[i * 3 + 2] = z;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('basePos', new THREE.BufferAttribute(velocities, 3));

        particleMaterial = new THREE.PointsMaterial({
            color: document.getElementById('colorPicker').value,
            size: 0.05,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
    }

    /**
     * HAND TRACKING LOGIC
     */
    const videoElement = document.getElementById('video-input');
    const statusElement = document.getElementById('hand-status');

    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusElement.innerText = "Hand Detected";
            const landmarks = results.multiHandLandmarks[0];

            // 1. Get Palm Position (using middle finger MCP as center)
            // Normalize 0-1 to Three.js coordinates (-5 to 5)
            handX = (0.5 - landmarks[9].x) * 10;
            handY = (0.5 - landmarks[9].y) * 10;

            // 2. Detect Scaling (Hand Closure)
            // Distance between wrist (0) and middle finger tip (12)
            const dx = landmarks[0].x - landmarks[12].x;
            const dy = landmarks[0].y - landmarks[12].y;
            const handSize = Math.sqrt(dx*dx + dy*dy);
            // If handSize is small, hand is likely a fist
            targetScale = THREE.MathUtils.mapLinear(handSize, 0.1, 0.4, 0.2, 1.5);

            // 3. Detect Expansion (Tension)
            // Distance between thumb tip (4) and index tip (8)
            const tx = landmarks[4].x - landmarks[8].x;
            const ty = landmarks[4].y - landmarks[8].y;
            const pinchDist = Math.sqrt(tx*tx + ty*ty);
            // Wider pinch = more expansion
            targetExpansion = THREE.MathUtils.mapLinear(pinchDist, 0.05, 0.3, 0.8, 3.0);

        } else {
            statusElement.innerText = "No hand detected";
            targetScale = 0.5; // Shrink when lost
        }
    });

    const cameraFeed = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480
    });
    cameraFeed.start();

    /**
     * UI CONTROLS
     */
    function setTemplate(type) {
        currentTemplate = type;
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${type}`).classList.add('active');
        createParticles();
    }

    function updateColor(hex) {
        if (particleMaterial) {
            particleMaterial.color.set(hex);
        }
    }

    /**
     * ANIMATION LOOP
     */
    function animate() {
        requestAnimationFrame(animate);

        if (particles) {
            // Smoothly interpolate position
            particles.position.x += (handX - particles.position.x) * 0.1;
            particles.position.y += (handY - particles.position.y) * 0.1;

            // Smoothly interpolate scale
            const s = THREE.MathUtils.lerp(particles.scale.x, targetScale, 0.1);
            particles.scale.set(s, s, s);

            // Update particle vertex expansion
            const positions = particleGeometry.attributes.position.array;
            const basePositions = particleGeometry.attributes.basePos.array;

            // Interpolate expansion factor
            let currentExp = THREE.MathUtils.lerp(1, targetExpansion, 0.1);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = basePositions[i * 3] * currentExp;
                positions[i * 3 + 1] = basePositions[i * 3 + 1] * currentExp;
                positions[i * 3 + 2] = basePositions[i * 3 + 2] * currentExp;
            }
            particleGeometry.attributes.position.needsUpdate = true;

            // Subtle rotation for life
            particles.rotation.y += 0.005;
        }

        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    createParticles();
    animate();
</script>
</body>
</html>